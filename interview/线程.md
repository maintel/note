#  如何结束掉一个线程，如果当前线程在阻塞着怎么结束

在 run 方法结束后，线程会自动结束

结束线程可以通过加入一个标记为，然后通过不断轮询这个标记为来判断是否跳出。但是在线程被阻塞的情况下就不行了。

对于阻塞着的操作，可以使用 interrupt 来结束线程，这个时候要注意异常的捕获。

```java
    @Override
    public void run() {

        try {
            sleep(5000);
        }catch (Exception e){
            System.out.println(e.getMessage());
        }

    }

    //Main.java_main()
        TestThread testThread = new TestThread();
        testThread.start();
        System.out.println("在50秒之内按任意键中断线程!");
        System.in.read();
        testThread.interrupt();
        testThread.join();
        System.out.println("线程已经退出!");
```

- Android 中都有哪些线程池？他们之间有什么不同？

- 多线程如何保证同步，遇到死锁怎么定位并解决？

https://www.cnblogs.com/digdeep/p/4448148.html

# run 和 start 的区别

- run 是直接开始执行 run 方法中的内容，程序会等待 run 方法执行完才继续向下执行，在这之前会一直阻塞着，即使使用了 sleep 来让出 cpu 也不行。而且，使用 run 方法其实和调用一个普通类实例中的方法一样，还是在一个线程中执行的，并没有开启多线程。

- start 是真正的开启多线程的方法，让线程处于就绪状态，并不是真正的开始执行，具体什么时候开始执行要看 cpu 的调度。start 方法会开启新的线程，使 run 方法在新的线程中执行。

# Thread 和 runnable 的区别

- 如果实现一个线程类继承了 Thread 那么它就不能再继承其他类了，这样在程序设计上面会有局限性。

- Runnable 适合于共享资源，适合用多线程去处理同一个资源。

- 线程池只能放入实现Runable或callable类线程，不能直接放入继承Thread的类

# 线程的状态

- 新建状态：新创建了一个线程对象。

- 就绪状态：线程对象创建后，其他线程调用了该对象的 start() 方法。该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权。

- 运行状态：就绪状态的线程获取了CPU，执行程序代码。

- 阻塞状态：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：

    - 等待阻塞：运行的线程执行wait()方法，JVM会把该线程放入等待池中。(wait会释放持有的锁)

    - 同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。

    - 其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。（注意,sleep是不会释放持有的锁）

- 死亡状态：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。

# 线程调度

- 线程优先级：线程的默认优先级是一样的都是 5 包括主线程也是一样的。可以通过 setPriority 来设置线程的优先级，范围在 1-10 之间，越高则优先级越高，越容易获取到 cpu 的执行。线程的优先级有继承关系，比如A线程中创建了B线程，那么B将和A具有相同的优先级。

- 线程睡眠：Thread.sleep(long millis)方法，使线程转到阻塞状态。millis参数设定睡眠的时间，以毫秒为单位。当睡眠结束后，就转为就绪（Runnable）状态。sleep()平台移植性好。

- 线程等待：Object类中的wait()方法，导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 唤醒方法。这个两个唤醒方法也是Object类中的方法，行为等价于调用 wait(0) 一样。

- 线程让步：Thread.yield() 方法，暂停当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程。

- 线程加入：join()方法，等待其他线程终止。在当前线程中调用另一个线程的join()方法，则当前线程转入阻塞状态，直到另一个进程运行结束，当前线程再由阻塞转为就绪状态。
 
- 线程唤醒：Object类中的notify()方法，唤醒在此对象监视器上等待的单个线程。如果所有线程都在此对象上等待，则会选择唤醒其中一个线程。选择是任意性的，并在对实现做出决定时发生。线程通过调用其中一个 wait 方法，在对象的监视器上等待。 直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程。被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争；例如，唤醒的线程在作为锁定此对象的下一个线程方面没有可靠的特权或劣势。类似的方法还有一个notifyAll()，唤醒在此对象监视器上等待的所有线程。

# 常用方法说明

## sleep

让当前正在执行的线程休眠指定的时间，在线程同步中 sleep 是不会释放锁的，也就是说即使线程被休眠也会持有着锁，从而阻塞着其他需要锁的线程。

## join

等待线程终止，join是Thread类的一个方法，启动线程后直接调用，即join()的作用是：“等待该线程终止”，这里需要理解的就是该线程是指的主线程等待子线程的终止。也就是在子线程调用了join()方法后面的代码，只有等到子线程结束了才能执行。比如一个线程需要另外一个线程的计算结果或者什么时，可以使用此函数。

## yield
    
暂停当前正在执行的线程对象，并执行其他线程。应该做的是让当前运行线程回到可运行状态，以允许具有相同优先级的其他线程获得运行机会。因此，使用yield()的目的是让相同优先级的线程之间能适当的轮转执行。但是，实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。

## wait

wait 是 object 的方法，它必须和 notify 以及 synchronized 一起使用，否则会抛出异常。作用是在获取锁对象后，主动释放锁同时线程休眠，直到其他线程使用 notify 唤醒，或者休眠时间到。但有一点需要注意的是notify()调用后，并不是马上就释放对象锁的，而是在相应的synchronized(){}语句块执行结束，自动释放锁后，JVM会在wait()对象锁的线程中随机选取一线程，赋予其对象锁，唤醒线程，继续执行。这样就提供了在线程间同步、唤醒的操作。Thread.sleep()与Object.wait()二者都可以暂停当前线程，释放CPU控制权，主要的区别在于Object.wait()在释放CPU同时，释放了对象锁的控制。
    
## interrupt

给线程发送一个中断信号，让线程在无限循环或者阻塞等的时候抛出一个异常`InterruptedException`从而结束线程，如果在线程内部自己处理了这个异常的话，线程还是不会被结束掉的。


# sleep 和 wait 的共同点和区别

相同点：

- 都可以使线程暂停等待，并让出 CPU 使用权。

- wait()和sleep()都可以通过interrupt()方法 打断线程的暂停状态 ，从而使线程立刻抛出InterruptedException。 
   
   如果线程A希望立即结束线程B，则可以对线程B对应的Thread实例调用interrupt方法。如果此刻线程B正在wait/sleep/join，则线程B会立刻抛出InterruptedException，在catch() {} 中直接return即可安全地结束线程。如果线程只是正常的执行，并没有调用 wait 等方法，则不会抛出异常的。

不同点：

- sleep 是 Thread 的方法类，wait 是 Object 的方法类。

- 在使用锁进行线程间同步的时候，sleep 没有释放锁，wait 释放了锁。

- wait 必须在同步代码块中使用，sleep 可以在任意位置使用。