# Java 基础

## java中==和equals和hashCode的区别

- ==

  对于基本数据类型 byte、short、int、long、double、char、float、boolean 比较的是他们的值
  对于符合数据类型，比较的是他们在内存中存放的地址。

- equals

  对于基类 object 中的 equals 方法比较的是对象在内存中的地址，但是在一些类中有自己的实现，比如 String，Date，Integer等。
  所以一般在没有复写 equals 方法的类中 equals 和 == 是一样的，和 == 相比 equals 的特殊之处在于他可以被覆盖。

- hashCode

  hashCode 返回的是对象在内存中的地址转换成的一个 int 值，所以如果没有重写 hashCode 方法，任何对象都是不相等的。
  hashCode 主要用在基于散列值得集合类中，用来比较 key 是否相等。（其实也用到了 equals）

在复写 equals 时一定要复写 hashCode 方法，以确保结合基于散列值得集合类使用时能够正常工作。

## int、char、long等各占多少字节数

|类型|占用字节(B)|bit数|取值范围|
|:--|:------|:----|:-----|
|int|4|4*8|-2^31~2^31-1|
|short|2|2*8|-2^15~2^15-1|
|long|8|8*8|-2^63~2^63-1|
|byte|1|1*8|-128~127|
|float|4|4*8|	1.4E-45~3.4028235E38|
|double|8|8*8|4.9E-324~1.7976931348623157E308|
|char|2|2*8||
|boolean|1|1*8||

## int与integer的区别

int 是基本数据类型（面向过程留下的痕迹，不过是对java的有益补充），Integer 是一个类，是int的扩展，定义了很多的转换方法
[参看](https://www.cnblogs.com/shenliang123/archive/2011/10/27/2226903.html)

## 谈谈对java多态的理解

**定义：** 多态指允许不同类的对象对同一消息做出响应。即不同的类对同一消息可以根据发送对象的不同而采用多种不同的行为方式。（发送消息就是函数调用）

实现多态的技术称为：动态绑定（dynamic binding），是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。

多态的实现条件:
- 要有继承
- 要有重写
- 父类引用指向子类对象

java 中多态的实现方式有：

- 接口实现
- 继承父类，并对方法进行重写

[参看](https://www.cnblogs.com/jack204/archive/2012/10/29/2745150.html)
[参看](http://www.importnew.com/20079.html)

## String、StringBuffer、StringBuilder区别

- String

  String 是不可变的对象, 因此在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象。

- StringBuffer

  StringBuffer 对象每次更改都会对 StringBuffer 对象本身进行操作，而不是生成新的对象。而且 StringBuffer 是线程安全的

- StringBuilder 

  StringBuilder 是与 StringBuffer 兼容，但不保证同步，该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。如果可能，建议优先采用该类，因为在大多数实现中，它比 StringBuffer 要快。两者的方法基本相同。

因此一般来讲，大部分情况下 StringBuffer 比 String 性能更好，特别是在多线程以及在使用被频繁修改的字符串中。而在单线程中 StringBuilder 比 StringBuffer 效率更高。

[参看](https://blog.csdn.net/rmn190/article/details/1492013)

## 什么是内部类？内部类的作用
## 成员内部类、静态内部类、局部内部类和匿名内部类的理解，以及项目中的应用

内部类就是在一个类或者方法内部定义的类。

内部类优点：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。

作用：

- 内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立。

- 在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。

- 创建内部类对象的时刻并不依赖于外围类对象的创建。

- 内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。

- 内部类提供了更好的封装，除了该外围类，其他类都不能访问。

内部类可以无限制的访问外围类的元素。

内部类是个编译时的概念，一旦编译成功后，它就与外围类属于两个完全不同的类（当然他们之间还是有联系的）

内部类分为：成员内部类、匿名内部类、静态内部类、局部内部类

- 成员内部类

  成员内部类中不能存在任何static的变量和方法；
  成员内部类是依附于外围类的，所以只有先创建了外围类才能够创建内部类。

- 局部内部类

  在一个方法中的内部类，作用域仅限于该方法。

- 匿名内部类

  android 中用的最多的就是 onClick 监听，一般用来实现一个接口。

- 静态内部类

  静态内部类与非静态内部类之间存在一个最大的区别，我们知道非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围内，但是静态内部类却没有。

  它的创建是不需要依赖于外围类的。

  它不能使用任何外围类的非static成员变量和方法。

  在静态内部类中可以存在静态成员。

  其实他已经和一个正常的类没有什么区别。

内部类的好处：

- 它将只用在其他一个地方的类在逻辑上实现了更好的分组。
- 提高了封装程度。
- 提供更好的可读性和可维护性。

[参考](https://www.cnblogs.com/chenssy/p/3388487.html)

## 静态内部类的设计意图

因为创建内部类实例时，这个实例会持它外部类的引用，这使得在内部类里可以直接使用外部类的成员变量和方法。但是很多时候我们并不需要它，而持有的引用会导致外部类不能被GC回收，容易产生内存泄漏。如果加上static将他变成静态内部类时，在编译的时候内部类会被编译成一个独立常规的类，静态内部类的实例不会持有外部类的引用，至于为什么还要写成内部类，我想就是上面的好处吧。

## 抽象类和接口区别

- 抽象类

  抽象类是用来捕捉子类的通用特性的。它不能被实例化，只能被用作子类的超类。抽象类是被用来创建继承层级里子类的模板

- 接口

  接口是抽象方法的集合。如果一个类实现了某个接口，那么它就继承了这个接口的抽象方法。这就像契约模式，如果实现了这个接口，那么就必须确保使用这些方法。接口只是一种形式，接口自身不能做任何事情。

最直观的答案就是：抽象类可以做一些自己是事情，而接口自己不做任何事情，只是定义了一些需要做的事情。

![区别](http://blogqn.maintel.cn/QQ20180326-145054@2x.png?e=3098847081&token=cs2nCfx72Y7hW0_NpFYzb3Jab90IJWraRtphMd-q:1PehhUKlKVu2bTjolyr5AH7VgAw=)

## 抽象类的意义

将子类的重复内容抽取封装，省去了一些重复性的操作。
为子类定义抽象方法，他们的实现是不同的，但是定义一致。是实现多态的重要手段。
提供了规范性，通过定义一些主要的方法，而利用子类来实现它们，达到程序代码的标准规范。
易于扩展和维护。

## 抽象类与接口的应用场景

- 如果想实现多重继承，必须使用接口
- 如果想拥有一些方法并且有一些公共的默认实现，就用抽象类
- 如果基本功能不断在改变，就是用抽象类

## 抽象类是否可以没有方法和属性？

可以

## 接口的意义

和抽象类的意义差不多，也是实现 java 多态的一个重要手段。
规范，接口可以有架构人员来定义告诉下面的开发人员做什么，但是不需要关心怎么做。
实现回调（这个算是作用吧）
易于维护和扩展，通过接口实现调用者持有接口的引用，后面更换实现类也对接口方法的调用没有影响。
安全，接口是松耦合的一种重要实现手段，它描述了系统对外的一些服务，但是外部并不能知道它内部的具体实现细节。


## 泛型中 extends 和 super 的区别

分别代表了上下界，如下有 B 继承自 A，
```java

public class Palte<T>{
  private T item;
  public Palte(T t){
    item = t;
  }
  public void set(T t){item=t;}
  public T get(){return item;}
}

Palte<A> palte = new Palte<B>(new B()); // 不通过，会报类型不匹配 因为无法将 Palte<B> 转换成 Palte<A> 即使 B 继承自 A
Palte<? extends A> palte2 = new Palte<B>(new B()); // 可以通过 Palte<? extends A> 表示所有继承自 A 的子类都可以通过
Palte<? super A> palte2 = new Palte<B>(new B()); //不通过 因为 Palte<? super A>  所有是 A 的父类的可以通过 A是最下界
Palte<? super B> palte3 = new Palte<A>(new A()); // 通过 表示所有是 B 父类的类型可以通过 ，A 是 B 的父类。
```

- extends

  代表上界，表示通配所有继承自 extends 后的类型的参数

  但是使用此通配符获得的类型只能 get 不能 set，因为编译器不知道 set 进入的具体是什么类型

- super

  代表下界，表示通配所有是 super 后类型父类的参数

  使用此通配符获得的类型 get 后获取到的是一个 object 类型，但是 set 方法可以使用，不过只能 set super 后类型以及它的子类。
  因为只能向上转型不能向下转型，编译器会自动将set的值向上转型为最小粒度的类型。

## 父类的静态方法能否被子类重写

不能。当类中的方法声明为static时，这个方法就和此类创建的对象脱离了关系。因为静态方法从程序开始运行后就已经分配了内存，也就是说已经写死了。所有引用到该方法的对象（父类的对象也好子类的对象也好）所指向的都是同一块内存中的数据，也就是该静态方法。

## 静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？

可以被继承，但是不能被重写，而是被隐藏。原因如上面

重写和隐藏的区别是："重写"后子类的优先级要高于父类的优先级，但是“隐藏”是没有这个优先级之分的。  

## 进程和线程的区别

一个程序至少有一个进程，一个进程至少有一个线程。

线程是 cpu 调度的最小单位。
进程是操作系统分配资源的单位。

进程执行过程中有独立的内存单元，而多个线程共享内存。

每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在进程中，由进程提供多个线程执行控制。

## final，finally，finalize的区别

除了长得差不多没有共同点

- final
  
  是修饰符，用于声明属性,方法和类, 分别表示属性不可变, 方法不可覆盖, 类不可继承.

- finally

  是异常处理语句结构的一部分，表示总是执行.

- finalize

  是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等. JVM不保证此方法总被调用.

## 序列化的方式

Serializable、Externalizable、Parcelable

- Serializable

  静态变量不参与序列化,要想将父类对象也序列化，就需要让父类也实现Serializable 接口。多次写入同一对象时，出第一次外，之后只保存写的引用,如果我们和 Parcelable 一样来自己实现写入和读取，Serializable 的速度更快！
  writeObject()与readObject()都是private方法，因此Serializable 采用了反射机制。

- Externalizable

  Externalizable 内部也是实现了 Serializable 接口
  是 JDK 中提供的又一个序列化接口,与 Serializable不同的是，需要我们自己实现 writeExternal 和 readExternal 来完成序列化，而不像 Serializable 有默认的 defaultReadObject 和 defaultWriteObject。

- Parcelable

  Parcelable 是为 Android 程序间(AIDL)高效的传输数据而设计

[参考](https://blog.csdn.net/wbwjx/article/details/55224982)

[参考](https://www.ibm.com/developerworks/cn/java/j-lo-serial/)

## Serializable 和 Parcelable 的区别

Parcelable 需要自己实现 writeExternal 和 readExternal 来完成序列化。

Serializable 内部使用了反射机制来进行序列化，序列化过程比较慢，这种机制会在序列化的时候创建许多的临时对象，容易触发垃圾回收。

Parcelable 由于自己实现了序列化和反序列化过程，因此速度会比 Serializable 快。

## 谈谈对kotlin的理解

语法、代码简洁，代码量会降低很多。

更好的 lambda 语法，以及高阶函数的使用，用来替代匿名内部类，回调接口等。

语法糖语法，函数式编程等。

因为是 JVM 语言所以对 Java 代码无缝切换和调用，基于 kotlin 的库以及一些框架还不丰富，不够和 Java 的无缝切换解决了这个问题。

但是现在社区的力量还不够强大。

函数式编程，大量的 lambda 和 高阶函数使用，对不懂或者生疏的人来说阅读代码会变得很困难。

闭包，空安全等。函数式编程有时候会使代码变得难以调试。有时候写空安全的？ ！！ 写的也挺烦的。

[知乎](https://www.zhihu.com/question/25289041)

## 闭包和局部内部类的区别

闭包：一个持有外部环境变量的函数就是闭包。 这样来讲所有访问了外部环境变量的函数就是闭包了，平时使用过程中有很多时候特性就是闭包。

一个纯粹（无副作用)的函数如果不含有自由变量，那么每次用相同的参数调用后的得到的结果肯定是一样的。但如果一个函数含有自由变量，那么调用返回的结果不但依赖于参数的值，还依赖于自由变量的值。因此一个含有自由变量的函数要正确执行，必须保证其所依赖的外围环境的存在。

[参看](http://rednaxelafx.iteye.com/blog/245022)

局部内部类访问它外部的一些环境变量的时候就形成了闭包。

外部方法对局部内部类形成闭包，但是闭包不一定需要局部内部类。

而且，局部内部类是一个类，而闭包说的是一种环境，或者叫特性。

## string 转换成 integer的方式及原理

方式：valueOf() 方法

[参看](https://blog.csdn.net/treeroot/article/details/92923)



