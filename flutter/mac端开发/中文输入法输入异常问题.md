# mac 上键盘输入拼音事件在删除时及删除后异常的问题

具体问题就是当输入拼音未输入完时按 back键删除此时输入框回调会有问题，重复输入，光标位置不正确等。

目前这个问题在 2.8.1 版本依然存在。

处理方法仅针对 flutter 2.2.3 版本：

修改 editable_text.dart  updateEditingValue 方法，针对 macos 做单独处理：处理删除后再次输入光标不正确的问题。

```dart
//  方法开始加上
        bool needUpdate = false;
        if(Platform.isMacOS && value.composing.start == 0 && value.composing.isNormalized && !value.composing.isCollapsed){
      int composingLength =   value.composing.end -  value.composing.start;
      int baseOffset = _value.selection.baseOffset + _value.composing.start - _value.composing.end;
      int trimNum = value.text.trimRight().substring(value.composing.start,value.composing.end).split(" ").length;
      
      // 需要重新组装字符串
      String compsStr = value.text.substring(value.composing.start,value.composing.end);
      String normorlValue = value.text.substring(value.composing.end,_value.selection.extentOffset +trimNum);
      
      value = TextEditingValue(text: value.text.replaceRange(value.composing.start, _value.selection.extentOffset +trimNum, "${normorlValue}${compsStr}"),
      composing: TextRange(start: baseOffset  ,end:baseOffset + composingLength ), 
      selection: TextSelection(baseOffset: _value.selection.baseOffset + trimNum,extentOffset: _value.selection.extentOffset +trimNum,affinity: value.selection.affinity,isDirectional: value.selection.isDirectional));

    } else if(Platform.isMacOS && value.composing.start == -1 && value.composing.end == -1 && _value.composing.start != -1){
      int trimNum = _value.text.trimRight().substring(_value.composing.start,_value.composing.end).split(" ").length;
     
      if(_value.selection.baseOffset + _value.composing.start - _value.composing.end + trimNum != value.selection.baseOffset){

      String compsStr = value.text.substring(0,value.selection.extentOffset);
      String normorlValue = value.text.substring(value.selection.extentOffset,_value.selection.baseOffset + _value.composing.start - _value.composing.end + trimNum);
      value = TextEditingValue(text: value.text.replaceRange(0, _value.selection.baseOffset + _value.composing.start - _value.composing.end + trimNum, "${normorlValue}${compsStr}"),
      composing: TextRange(start: -1  ,end:-1 ), 
      selection: TextSelection(baseOffset: _value.selection.baseOffset + _value.composing.start - _value.composing.end + trimNum,extentOffset: _value.selection.extentOffset + _value.composing.start - _value.composing.end +trimNum,affinity: value.selection.affinity,isDirectional: value.selection.isDirectional));

      /// 说明是删除后的， 更新一下 编辑状态，强制刷新一下
      needUpdate = true;
      }

    }


// 结束加上
    if(needUpdate){
      renderEditable.textSelectionDelegate.userUpdateTextEditingValue(_value.copyWith(selection: _value.selection.copyWith(baseOffset: _value.selection.baseOffset-1,extentOffset:  _value.selection.extentOffset-1)), SelectionChangedCause.keyboard);
      renderEditable.textSelectionDelegate.userUpdateTextEditingValue(_value.copyWith(selection: _value.selection.copyWith(baseOffset: _value.selection.baseOffset-1,extentOffset:  _value.selection.extentOffset-1)), SelectionChangedCause.keyboard);

      renderEditable.textSelectionDelegate.userUpdateTextEditingValue(_value.copyWith(selection: _value.selection.copyWith(baseOffset: _value.selection.baseOffset+1,extentOffset:  _value.selection.extentOffset+1)), SelectionChangedCause.keyboard);
      renderEditable.textSelectionDelegate.userUpdateTextEditingValue(_value.copyWith(selection: _value.selection.copyWith(baseOffset: _value.selection.baseOffset+1,extentOffset:  _value.selection.extentOffset+1)), SelectionChangedCause.keyboard);

    }
```

在 editable.dart  修改 _handleDelete 方法，处理删除时重复输入的问题


```dart
    final TextSelection newSelection = TextSelection.collapsed(offset: cursorPosition);
        TextRange newTextRange = Platform.isMacOS
        ? textSelectionDelegate.textEditingValue.composing.start - 1 ==
                    textSelectionDelegate.textEditingValue.composing.end ||
                textSelectionDelegate.textEditingValue.composing.start ==
                    textSelectionDelegate.textEditingValue.composing.end - 1
            ? TextRange.empty
            : TextRange(
                start: forward
                    ? textSelectionDelegate.textEditingValue.composing.start <=
                            -1
                        ? textSelectionDelegate.textEditingValue.composing.start
                        : textSelectionDelegate
                                .textEditingValue.composing.start -
                            1
                    : textSelectionDelegate.textEditingValue.composing.start,
                end: forward
                    ? textSelectionDelegate.textEditingValue.composing.end
                    : textSelectionDelegate.textEditingValue.composing.end <= -1
                        ? textSelectionDelegate.textEditingValue.composing.end
                        : textSelectionDelegate.textEditingValue.composing.end -
                            1)
        : TextRange.empty;
    _setTextEditingValue(
      TextEditingValue(
        text: textBefore + textAfter,
        selection: newSelection,
        composing: newTextRange
      ),
      SelectionChangedCause.keyboard,
    );
```

究其原因是在 text_input.dart 中 _handleTextInputInvocation 方法 mthod = TextInputClient.updateEditingState  再删除时回调不正确导致的， 比如输入了 陈c  ，此时删除结果为 陈，再次输入 c 回调的内容就变成了 c陈，使用 _setTextEditingValue 刷新了状态并重设光标位置，但是光标位置的状态并未奇效原因未知。所以在 updateEditingValue 中加上强制使用方向键移动几次光标来强制刷新光标的位置。


# 当 mac 键盘设置大写的时候删除失效的问题

原因是 当长按 capsLock 时 raw_keyborad.dart 中 _keysPressed 一直保存着 capsLock 按键事件，此时再按back或者del键， editable.dart 收到按键回调中对组合键检测的时候过滤掉了此事件。

```dart
keysPressed.difference(isMacOS ? _macOsModifierKeys : _modifierKeys).length > 1 || keysPressed.difference(_interestingKeys).isNotEmpty
```

处理方法仅针对 flutter 2.2.3 版本：

可以修改 editable.dart 中的 _handleKeyEvent 方法

```dart
    bool keyHidden = keysPressed.difference(isMacOS ? _macOsModifierKeys : _modifierKeys).length > 1 || keysPressed.difference(_interestingKeys).isNotEmpty;
    if(keyHidden && isMacOS){  // 当检测到时 mac 时，对组合键再做一次检测
      int isDel = 0;
      keysPressed.forEach((element) {
        if(element == LogicalKeyboardKey.capsLock){
          isDel++;
        }
        if(element == LogicalKeyboardKey.backspace){
          isDel++;
        }
        if(element == LogicalKeyboardKey.delete){
          isDel++;
        }
      });
      if(isDel >= 2){
        keyHidden = false;
      }
    }
    if (!_nonModifierKeys.contains(key) ||
        keyHidden) {
      // If the most recently pressed key isn't a non-modifier key, or more than
      // one non-modifier key is down, or keys other than the ones we're interested in
      // are pressed, just ignore the keypress.
      return;
    }
```
