可以参考以下文章：
https://zhuanlan.zhihu.com/p/59197944
https://zhuanlan.zhihu.com/p/38026271

首先需要明确的概念是，Dart 是单线程的并且 Flutter 依赖于 Dart。

当你启动一个 Flutter（或任何 Dart）应用时，将创建并启动一个新的线程进程（在 Dart 中为 「Isolate」），该线程将是在整个应用中唯一需要关注的。

所以，此线程创建后，Dart 会自动：

    初始化 2 个 FIFO（先进先出）队列（「MicroTask」和 「Event」）；
    并且当该方法执行完成后，执行 main() 方法，
    启动事件循环。


在线程的整个生命周期中，一个被称为事件循环的单一且隐藏的进程将决定你代码的执行方式及顺序（取决于 MicroTask 和 Event 队列）。

事件循环是一种无限循环（由一个内部时钟控制），在每个时钟周期内，如果没有其他 Dart 代码执行，则执行事件队列中的事件，其中 MicroTask 队列优先于 Event 队列。

# future

future 也是通过 event 来执行的，关于 future 需要理解的一点就是 **Future 并非并行执行，而是遵循事件循环处理事件的顺序规则执行**。

关于上面的理解可以是这样的，首先 dart 是单线程模型的，当执行一个 future 代码时，会把 future 放到event队列中，然后接着去执行同步代码，当没有同步代码要执行时才会执行队列中的事件。

同样的还有 async ，async 也是通过 future 的方式实现的，被 async 标记的方法会变成一个 future方法，被 async 标记的方法一样是先以同步执行代码的方式执行的，直到执行到第一个 await 关键字的时候。

上面的解释可以明白实际上不管是 future 还是 async 都没有实现真正的异步，只是看似是异步，实际上它们还是在同一个线程执行的，因为 dart 是单线程模型。

可以通过以下代码验证：

```dart
void method1() async{
    List<String> myArray = <String>['a','b','c'];
    print('before loop');
    print(DateTime.now().millisecondsSinceEpoch);

    List<String> results = List.filled(3, "fill");
    List<Future<String>> fileTasks = <Future<String>>[];  //模拟一个多线程处理任务
    myArray.forEach((String value) {
        fileTasks.add(delayedPrint(value));
    });
    await Future.wait(fileTasks).then((value){
        print(DateTime.now().millisecondsSinceEpoch);
        value.forEach((element) {
            print(element);
        });
        }
    );
}

Future<String> delayedPrint(String value) async {
  sleep(Duration(seconds: 2));  // 模拟耗时
  return "$value";
}
```

上面的代码结束和开始的耗时是6秒而不是2秒。就是因为上面说的 dart 是单线程的，所以执行event队列中的 future 时实际上也是按照顺序执行的。

# 真正的异步Isolate